"""A perfect-random version of Lorenz-96.

Used by `bib.grudzien2020numerical` to study the precision of
stochastic integration schemes.

Both the model and truth are to be integrated by the same *random* model (with almost
surely different outcomes).  For simplicity, this case should be used with `Q = 0`, i.e.
with no model error (as perceived by the DA schemes).  Inflation, localisation, and
other auxiliary techiques may be used to handle sampling error and perform
regularization.

The truth twin should be generated by the order 2.0 Taylor scheme below,
for the accuracy with respect to convergence in the strong sense.
See `bib.grudzien2020numerical` for a full discussion of benchmarks on this
model and statistically robust configurations.

This study uses no multiplicative inflation / localization or other
regularization instead using a large ensemble size in the perturbed
observation EnKF as a simple estimator to study the asymptotic filtering
statistics under different model scenarios.

The purpose of the study in `bib.grudzien2020numerical` was to explore the relationships
between:

- numerical discretization error in truth twins;
- numerical discretization error in model twins;
- model uncertainty in perfect-random models;
- filter divergence and / or bias in filtering forecast statistics;

Numerical discretization error increases with dt, with the strong / weak order of
convergence discussed in the refs.  Although the orders of convergence of the
stochastic Runge-Kutta and the Euler-Maruyama model match, it is shown that
the step size configuration above keeps the discretization error for the model and
truth twins bounded by approximately $10^{-3}$ in expectation.

Model uncertainty increases with the diffusion, representing the "instantaneous"
standard deviation of the model noise at any moment. Larger diffusion
thus corresponds to a wider variance of the relizations of the diffeomorphsims
that generate the model / truth twin between observation times.

It is demonstrated by `bib.grudzien2020numerical` that the model error due to
discretization of the SDE equations of motion is most detrimental to the filtering cycle
when model uncertainty is low and observation precision is high.  In other
configurations, such as those with high model uncertainty, the differences between
ensembles with low discretization error (those using the Runge-Kutta scheme) and high
discretization error (those using the Euler-Maruyama scheme) tend to be relaxed.

Set-up with three different `step` functions, using different SDE integrators.
The truth twin is generated by the order 2.0 Taylor scheme, for accuracy with
respect to convergence in the strong sense for generating the observation sequence.
The model simulation step sizes are varied in the settings below to demonstrate the
differences between the commonly uses Euler-Maruyama and the more statistically
robust Runge-Kutta method for SDE integration. See README in `dapper.mods.Lorenz96s`.
"""

import numpy as np

from dapper.mods.integration import rk4
from dapper.mods.Lorenz96 import dxdt, dxdt_autonomous, shift
from dapper.mods.Lorenz96.extras import LPs, d2x_dtdx, dstep_dx

################################
# Global parameter definitions #
################################

# energy injected into the system
Force = 8.0

# recommended time series plot length
Tplot = 10

# set the model state vector dimension
# Note: the second order Taylor-Stratonovich scheme can be
# fairly expensive to run, and a reduced order model with
# Nx=10 is a suggested setting for a robust twin experiment
# on a lower-power machine
Nx = 40

# set the diffusion parameter, defining the intensity of the
# stochasticity / model uncertainty
diffusion = 0.1


####################################
# 2nd order strong taylor SDE step #
####################################
def l96s_tay2_step(x, t, dt, s):
    """Advance state of L96s model using order-2.0 Taylor scheme.

    This is the method that should be used to generate the truth twin for this model due
    to the high-accuracy with respect to convergence in the strong sense. The ensemble
    model twin will be generated by on of the wrappers below.  The order 2.0
    Taylor-Stratonovich discretization scheme implemented here is the basic formulation
    which makes a Fourier truncation at p=1 for the Brownian bridge process. See
    `bib.grudzien2020numerical` for full details of the scheme and other versions."""

    # Infer system dimension
    sys_dim = len(x)

    # Compute the deterministic dxdt and the jacobian equations
    dx = dxdt(x)
    dxF = d2x_dtdx(x)

    # coefficients defined based on the p=1 Fourier truncation
    rho = 1.0/12.0 - 0.5 * np.pi**(-2)
    alpha = np.pi**2 / 180.0 - 0.5 * np.pi**(-2)

    # draw standard normal sample to define the
    # recursive Stratonovich integral coefficients
    rndm = np.random.standard_normal([5, sys_dim])
    xi, mu, phi, zeta, eta = rndm

    # define the auxiliary functions of random Fourier coefficients, a and b
    a = -2.0 * np.sqrt(dt * rho) * mu - np.sqrt(2.0*dt) * zeta  / np.pi
    b = np.sqrt(dt * alpha) * phi + np.sqrt(dt / (2.0 * np.pi**2) ) * eta

    # vector of first order Stratonovich integrals
    J_pdelta = (dt/2.0) * (np.sqrt(dt) * xi + a)

    def Psi(l1, l2):
        # psi will be a generic function of the indicies l1 and l2, we will define
        # psi plus and psi minus via this
        psi = dt**2 * xi[l1] * xi[l2] / 3.0 + dt * a[l1] * a[l2] / 2.0 \
              + dt**(1.5) * (xi[l1] * a[l2] + xi[l2] * a[l1]) / 4.0 \
              - dt**(1.5) * (xi[l1] * b[l2] + xi[l2] * b[l1]) / (2.0 * np.pi)
        return psi

    # we define the approximations of the second order Stratonovich integral
    psi_plus = np.array([Psi((i-1) % sys_dim, (i+1) % sys_dim)
                         for i in range(sys_dim)])
    psi_minus = np.array([Psi((i-2) % sys_dim, (i-1) % sys_dim)
                         for i in range(sys_dim)])

    # the final vectorized step forward is given as
    x  = x + dx * dt + dt**2 * 0.5 * dxF @ dx  # deterministic taylor step
    x += s * np.sqrt(dt) * xi                  # stochastic euler step
    x += s * dxF @ J_pdelta                    # stochastic first order taylor step
    x += s**2 * (psi_plus - psi_minus)         # stochastic second order taylor step

    return x


def steppers(kind):
    """Wrapper around the different model integrators / time steppers.

    Note that they all forward (i.e. use) the diffusion parameter.
    """
    def step(x0, t, dt):
        if kind == "EM":
            # Euler-Maruyama (order 1.0 Weak / Strong) integration
            return rk4(lambda x, t: dxdt(x), x0, np.nan, dt, s=diffusion, stages=1)
        elif kind == "RK4":
            # 4-stage Runge-Kutta (order 1.0 Weak / Strong) integration
            return rk4(lambda x, t: dxdt(x), x0, np.nan, dt, s=diffusion, stages=4)
        elif kind == "Tay2":
            # Taylor-Stratonovich (order 2.0 Weak / Strong) integration.
            return l96s_tay2_step(x0, np.nan, dt, diffusion)
        else:
            raise ValueError
    return step
